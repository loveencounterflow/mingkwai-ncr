// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, FS, ISL, MKNCR, NCR, PATH, badge, block_style_as_tex, debug, echo, get_file_time, glyph_style_as_tex, help, info, log, populate_isl, populate_isl_with_sims, populate_isl_with_tex_formats, read_cache, rewrite_cache, rpr, step, u, urge, warn;

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MINGKWAI-NCR';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  NCR = require('ncr');

  module.exports = MKNCR = NCR._copy_library('xncr');

  ISL = MKNCR._ISL;

  u = MKNCR.unicode_isl;

  (function(_this) {
    return (function() {
      var i, len, reducers, sim_tag, sim_tags;
      sim_tags = ['sim/source/global', 'sim/source/components', 'sim/source/components/search', 'sim/source/false-identity', 'sim/target/global', 'sim/target/components', 'sim/target/components/search', 'sim/target/false-identity'];
      reducers = {
        '*': 'skip',
        tag: 'tag',
        rsg: 'assign',
        tex: function(values, context) {

          /* TAINT should be a standard reducer */
          var R, i, len, name, sub_value, value;
          R = {};
          for (i = 0, len = values.length; i < len; i++) {
            value = values[i];
            for (name in value) {
              sub_value = value[name];
              R[name] = sub_value;
            }
          }
          return R;
        }
      };
      for (i = 0, len = sim_tags.length; i < len; i++) {
        sim_tag = sim_tags[i];
        reducers[sim_tag] = 'list';
      }

      /* TAINT experimental */
      return MKNCR._aggregate = ISL.aggregate.use(u, reducers);
    });
  })(this)();

  get_file_time = function(path, allow_missing) {
    var error, error1, stats;
    if (allow_missing == null) {
      allow_missing = false;
    }
    try {
      stats = FS.statSync(path);
    } catch (error1) {
      error = error1;
      if (!(allow_missing && error['code'] === 'ENOENT')) {
        throw error;
      }
      return -Infinity;
    }
    return +stats.mtime;
  };

  populate_isl = function(handler) {
    var S, cache_path, cache_time, must_rewrite_cache, source_time;
    S = {
      paths: {
        cache: PATH.resolve(__dirname, '../data/isl-entries.json'),
        mkts_options: PATH.resolve(__dirname, '../../mingkwai-typesetter/options.js'),
        jizura_datasources: PATH.resolve(__dirname, '../../../jizura-datasources/data/flat-files/')
      }
    };
    S.paths.strokeorders = PATH.resolve(S.paths.jizura_datasources, 'shape/shape-strokeorder-zhaziwubifa.txt');
    source_time = -Infinity;
    source_time = Math.max(source_time, get_file_time(S.paths.mkts_options));
    source_time = Math.max(source_time, get_file_time(S.paths.strokeorders));
    cache_time = get_file_time(S.paths.cache, true);
    must_rewrite_cache = cache_time < source_time;
    if (must_rewrite_cache) {
      if ((module.parent != null) && (handler == null)) {
        cache_path = PATH.relative(process.cwd(), S.paths.cache);
        warn("cache file");
        warn("" + cache_path);
        warn("is out of date");
        urge("run the command");
        urge(CND.white("node " + (PATH.relative(process.cwd(), __filename))));
        urge("to rebuild " + cache_path);
        throw new Error("cache " + S.paths.cache + " out of date");
      }
      rewrite_cache(S, handler);
    } else {
      if (handler == null) {
        handler = function(error) {
          if (error != null) {
            throw error;
          }
        };
      }
      read_cache(S, handler);
    }
    return null;
  };

  read_cache = function(S, handler) {
    var entry, i, len, ref;
    ref = require(S.paths.cache);
    for (i = 0, len = ref.length; i < len; i++) {
      entry = ref[i];
      ISL.add(u, entry);
    }
    if (handler != null) {
      handler(null, S);
    }
    return null;
  };

  rewrite_cache = function(S, handler) {
    help("rewriting cache");
    S.collector = [];
    step(function*(resume) {
      var entry, i, len, ref;
      (yield populate_isl_with_tex_formats(S, resume));
      (yield populate_isl_with_sims(S, resume));
      FS.writeFileSync(S.paths.cache, JSON.stringify(S.collector, null, '  '));
      ref = S.collector;
      for (i = 0, len = ref.length; i < len; i++) {
        entry = ref[i];
        ISL.add(u, entry);
      }
      if (handler != null) {
        return handler(null, S);
      }
    });
    return null;
  };

  populate_isl_with_tex_formats = function(S, handler) {
    var block_command, cid, entry, glyph, glyph_style, glyph_style_tex, glyph_styles, hi, i, len, lo, mkts_options, ref, rsg, tex, tex_command_by_rsgs;
    mkts_options = require(S.paths.mkts_options);
    tex_command_by_rsgs = mkts_options['tex']['tex-command-by-rsgs'];
    glyph_styles = mkts_options['tex']['glyph-styles'];
    for (rsg in tex_command_by_rsgs) {
      block_command = tex_command_by_rsgs[rsg];
      ref = ISL.find_entries(u, 'rsg', rsg);
      for (i = 0, len = ref.length; i < len; i++) {
        entry = ref[i];

        /* Note: must push new entries to collector, cannot recycle existing ones here */
        lo = entry.lo, hi = entry.hi, tex = entry.tex;
        if (tex == null) {
          tex = {};
        }
        tex['block'] = block_style_as_tex(block_command);
      }
      S.collector.push({
        lo: lo,
        hi: hi,
        tex: tex
      });
    }

    /* TAINT must resolve (X)NCRs */
    for (glyph in glyph_styles) {
      glyph_style = glyph_styles[glyph];
      cid = MKNCR.as_cid(glyph);
      glyph_style_tex = glyph_style_as_tex(glyph, glyph_style);
      S.collector.push({
        lo: cid,
        hi: cid,
        tex: {
          codepoint: glyph_style_tex
        }
      });
    }
    return handler(null, S);
  };

  populate_isl_with_sims = function(S, handler) {
    var $add_intervals, $collect_tags, S1, SIMS, input;
    $add_intervals = (function(_this) {
      return function() {
        return $(function(record) {
          var ctag, mtag, obj, obj1, otag, source_cid, source_glyph, target_cid, target_glyph;
          source_glyph = record.source_glyph, target_glyph = record.target_glyph;
          source_cid = MKNCR.as_cid(record['source_glyph']);
          target_cid = MKNCR.as_cid(record['target_glyph']);
          otag = record['tag'];
          mtag = "sim/target/" + otag;
          ctag = "sim sim/has-target sim/is-source sim/has-target/" + otag + " sim/is-source/" + otag + " sim/" + otag;
          S.collector.push((
            obj = {
              lo: source_cid,
              hi: source_cid
            },
            obj["" + mtag] = target_glyph,
            obj.tag = ctag,
            obj
          ));
          mtag = "sim/source/" + otag;
          ctag = "sim sim/has-source sim/is-target sim/has-source/" + otag + " sim/is-target/" + otag + " sim/" + otag;
          S.collector.push((
            obj1 = {
              lo: target_cid,
              hi: target_cid
            },
            obj1["" + mtag] = source_glyph,
            obj1.tag = ctag,
            obj1
          ));
          return null;
        });
      };
    })(this);
    $collect_tags = (function(_this) {
      return function() {
        var tags;
        tags = new Set;
        return $('null', function(record) {
          if (record != null) {
            tags.add(record['tag']);
          } else {
            debug('3334', tags);
          }
          return null;
        });
      };
    })(this);
    SIMS = require('../../jizura-db-feeder/lib/feed-sims');
    S1 = {};
    S1.db = null;
    S1.source_home = S.paths.jizura_datasources;
    input = SIMS.new_sim_readstream(S1, {
      filter: true
    });
    input.pipe($add_intervals()).pipe($('finish', function() {
      return handler(null, S);
    }));
    return null;
  };

  block_style_as_tex = function(block_style) {
    return "\\" + block_style;
  };

  glyph_style_as_tex = function(glyph, glyph_style) {

    /* NOTE this code replaces parts of `tex-writer-typofix._style_chr` */

    /* TAINT using `prPushRaise` here in place of `tfPushRaise` because it gives better
    results
     */
    var R, ref, ref1, ref2, ref3, rpl_chr, rpl_cmd, rpl_push, rpl_raise, use_tfpushraise;
    use_tfpushraise = false;
    R = [];
    R.push("{");
    rpl_push = (ref = glyph_style['push']) != null ? ref : null;
    rpl_raise = (ref1 = glyph_style['raise']) != null ? ref1 : null;
    rpl_chr = (ref2 = glyph_style['glyph']) != null ? ref2 : glyph;
    rpl_cmd = (ref3 = glyph_style['cmd']) != null ? ref3 : null;
    if (use_tfpushraise) {
      if ((rpl_push != null) && (rpl_raise != null)) {
        R.push("\\prPushRaise{" + rpl_push + "}{" + rpl_raise + "}{");
      } else if (rpl_push != null) {
        R.push("\\prPush{" + rpl_push + "}{");
      } else if (rpl_raise != null) {
        R.push("\\prRaise{" + rpl_raise + "}{");
      }
    } else {
      if ((rpl_push != null) && (rpl_raise != null)) {
        R.push("\\tfPushRaise{" + rpl_push + "}{" + rpl_raise + "}");
      } else if (rpl_push != null) {
        R.push("\\tfPush{" + rpl_push + "}");
      } else if (rpl_raise != null) {
        R.push("\\tfRaise{" + rpl_raise + "}");
      }
    }
    if (rpl_cmd != null) {
      R.push("\\" + rpl_cmd + "{}");
    }
    R.push(rpl_chr);
    if (use_tfpushraise && ((rpl_push != null) || (rpl_raise != null))) {
      R.push("}");
    }
    R.push("}");
    R = R.join('');
    return R;
  };

  if (module.parent != null) {

    /* If this module is `require`d from another module, run `populate_isl` *without* callback. This will
    succeed if cache is present and up to date; it will fail with a helpful message otherwise.
     */
    populate_isl();
  } else {

    /* If this module is run as a script, rebuild the cache when necessary: */
    populate_isl(function(error, S) {
      if (error != null) {
        throw error;
      }
      help("" + S.paths.cache);
      help("is up to date");
      return null;
    });
  }

}).call(this);

//# sourceMappingURL=main.js.map
