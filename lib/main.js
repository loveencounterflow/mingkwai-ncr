// Generated by CoffeeScript 1.12.4
(function() {
  var CND, FS, ISL, MKNCR, NCR, PATH, badge, block_style_as_tex, debug, echo, glyph_style_as_tex, help, info, log, main, new_state, populate_isl_with_extra_data, populate_isl_with_sims, populate_isl_with_tex_formats, read_cache, rewrite_cache, rpr, step, u, urge, warn,
    slice = [].slice,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MINGKWAI-NCR';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  step = require('coffeenode-suspend').step;

  NCR = require('ncr');

  module.exports = MKNCR = NCR._copy_library('xncr');

  ISL = MKNCR._ISL;

  u = MKNCR.unicode_isl;

  MKNCR.is_inner_glyph = function(glyph) {
    var ref;
    return (ref = this.as_csg(glyph)) === 'u' || ref === 'jzr';
  };

  MKNCR.jzr_as_uchr = function(glyph) {
    if ((this.as_csg(glyph)) === 'jzr') {
      return this.as_uchr(glyph);
    }
    return glyph;
  };

  MKNCR.jzr_as_xncr = function(glyph) {
    var nfo;
    nfo = this.analyze(glyph);
    if (!((nfo.rsg === 'u-pua') || (nfo.csg === 'jzr'))) {
      return glyph;
    }
    return this.as_chr(nfo.cid, {
      csg: 'jzr'
    });
  };

  MKNCR.normalize = function(glyph) {
    var cid, csg, rsg;
    throw new Error("XNCHR.normalize is deprecated");
    rsg = this.as_rsg(glyph);
    cid = this.as_cid(glyph);
    csg = rsg === 'u-pua' ? 'jzr' : 'u';
    return this.chr_from_cid_and_csg(cid, csg);
  };

  MKNCR.normalize_to_xncr = function(glyph) {
    var cid, csg;
    throw new Error("do we need this method?");
    cid = this.as_cid(glyph);
    csg = (this.as_rsg(glyph)) === 'u-pua' ? 'jzr' : this.as_csg(glyph);
    return this.chr_from_cid_and_csg(cid, csg);
  };

  MKNCR.normalize_to_pua = function(glyph) {
    var cid, csg;
    throw new Error("do we need this method?");
    cid = this.as_cid(glyph);
    csg = this.as_csg(glyph);
    if (csg === 'jzr') {
      csg = 'u';
    }
    return this.chr_from_cid_and_csg(cid, csg);
  };

  (function(_this) {
    return (function() {
      var aggregate, i, len, recipe, sim_tag, sim_tags;
      sim_tags = ['sim/source/global', 'sim/source/components', 'sim/source/components/search', 'sim/source/false-identity', 'sim/target/global', 'sim/target/components', 'sim/target/components/search', 'sim/target/false-identity'];
      recipe = {
        fallback: 'skip',
        fields: {
          tag: 'tag',
          rsg: 'assign',
          sim: 'list',
          tex: function(values, context) {

            /* TAINT should be a standard reducer */
            var R, i, len, name, sub_value, value;
            R = {};
            for (i = 0, len = values.length; i < len; i++) {
              value = values[i];
              for (name in value) {
                sub_value = value[name];
                R[name] = sub_value;
              }
            }
            return R;
          }
        }
      };
      for (i = 0, len = sim_tags.length; i < len; i++) {
        sim_tag = sim_tags[i];
        recipe['fields'][sim_tag] = 'list';
      }

      /* TAINT experimental */
      aggregate = ISL.aggregate.use(u, recipe, {
        memoize: true
      });
      (function() {
        var cache;
        cache = {};
        return MKNCR.describe = function() {
          var P, R, csg, id, key, nfo, rsg, tag, value;
          P = 1 <= arguments.length ? slice.call(arguments, 0) : [];

          /* TAINT what about gaiji? */
          id = JSON.stringify(P);
          if ((R = cache[id]) != null) {
            return R;
          }
          nfo = this.analyze.apply(this, P);
          csg = nfo.csg, rsg = nfo.rsg;
          if (csg === 'u') {
            R = aggregate(nfo['cid']);
          } else {
            R = {};
          }
          for (key in nfo) {
            value = nfo[key];
            R[key] = value;
          }

          /* Instead of doing proper multi-characterset treatment,
          consider all Private Use Area CPs and all non-Unicode CPs as being CJK:
           */
          if ((csg === 'u' && rsg === 'u-pua') || (csg !== 'u')) {
            tag = R['tag'] != null ? R['tag'] : R['tag'] = [];
            if (indexOf.call(tag, 'assigned') < 0) {
              tag.push('assigned');
            }
            if (indexOf.call(tag, 'cjk') < 0) {
              tag.push('cjk');
            }
            if (csg === 'jzr' && (R['tex'] == null)) {
              R['tex'] = (this.describe(R['cid']))['tex'];
            }
          }
          cache[id] = R;
          return R;
        };
      })();
      return null;
    });
  })(this)();

  new_state = function() {
    var R;
    R = {};
    R.paths = {};
    R.paths.cache = PATH.resolve(__dirname, '../data/isl-entries.json');
    R.paths.mkts_options = PATH.resolve(__dirname, '../../mingkwai-typesetter/lib/options.js');
    R.collector = [];
    return R;
  };

  read_cache = function(handler) {
    var S, entry, i, len, ref;
    if (handler == null) {
      handler = null;
    }
    help("reading cache");
    warn("cache may be stale; check with mingkwai file-date-checker");
    S = new_state();
    ref = require(S.paths.cache);
    for (i = 0, len = ref.length; i < len; i++) {
      entry = ref[i];
      ISL.add(u, entry);
    }
    if (handler != null) {
      handler(null, S);
    }
    return null;
  };

  rewrite_cache = function(handler) {
    var S;
    if (handler == null) {
      handler = null;
    }
    help("rewriting cache");
    S = new_state();
    step(function*(resume) {
      var entry, i, len, ref;
      yield populate_isl_with_tex_formats(S, resume);
      yield populate_isl_with_sims(S, resume);
      yield populate_isl_with_extra_data(S, resume);
      FS.writeFileSync(S.paths.cache, JSON.stringify(S.collector, null, '  '));
      ref = S.collector;
      for (i = 0, len = ref.length; i < len; i++) {
        entry = ref[i];
        ISL.add(u, entry);
      }
      if (handler != null) {
        return handler(null, S);
      }
    });
    return null;
  };

  populate_isl_with_tex_formats = function(S, handler) {
    var block_command, cid, cjk_rsgs, entry, fallback_command, glyph, glyph_style, glyph_style_tex, glyph_styles, hi, i, j, k, len, len1, len2, lo, mkts_options, ref, ref1, ref2, rsg, tex, tex_command_by_rsgs;
    mkts_options = require(S.paths.mkts_options);
    tex_command_by_rsgs = mkts_options['tex']['tex-command-by-rsgs'];
    glyph_styles = mkts_options['tex']['glyph-styles'];
    cjk_rsgs = mkts_options['tex']['cjk-rsgs'];
    fallback_command = block_style_as_tex((ref = tex_command_by_rsgs['fallback']) != null ? ref : 'mktsRsgFb');
    S.collector.push({
      lo: 0x000000,
      hi: 0x10ffff,
      tex: {
        block: fallback_command
      }
    });
    for (rsg in tex_command_by_rsgs) {
      block_command = tex_command_by_rsgs[rsg];
      if (rsg === 'fallback') {
        continue;
      }
      ref1 = ISL.find_entries(u, 'rsg', rsg);
      for (i = 0, len = ref1.length; i < len; i++) {
        entry = ref1[i];

        /* Note: must push new entries to collector, cannot recycle existing ones here */
        lo = entry.lo, hi = entry.hi, tex = entry.tex;
        if (tex == null) {
          tex = {};
        }
        tex['block'] = block_style_as_tex(block_command);
        S.collector.push({
          lo: lo,
          hi: hi,
          tex: tex
        });
      }
    }

    /* TAINT must resolve (X)NCRs */
    for (glyph in glyph_styles) {
      glyph_style = glyph_styles[glyph];
      if (glyph_style == null) {
        continue;
      }
      cid = MKNCR.as_cid(glyph);
      glyph_style_tex = glyph_style_as_tex(glyph, glyph_style);
      S.collector.push({
        lo: cid,
        hi: cid,
        tex: {
          codepoint: glyph_style_tex
        }
      });
    }
    for (j = 0, len1 = cjk_rsgs.length; j < len1; j++) {
      rsg = cjk_rsgs[j];
      ref2 = ISL.find_entries(u, 'rsg', rsg);
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        entry = ref2[k];

        /* Note: must push new entries to collector, cannot recycle existing ones here */
        lo = entry.lo, hi = entry.hi;
        S.collector.push({
          lo: lo,
          hi: hi,
          tag: ['cjk']
        });
      }
    }
    return handler(null, S);
  };

  populate_isl_with_extra_data = function(S, handler) {
    var chr, hi, i, len, lo, ref;
    ref = Array.from('\x20\n\r\t');
    for (i = 0, len = ref.length; i < len; i++) {
      chr = ref[i];
      lo = hi = MKNCR.as_cid(chr);
      S.collector.push({
        lo: lo,
        hi: hi,
        tag: ['ascii-whitespace']
      });
    }
    return handler(null, S);
  };

  populate_isl_with_sims = function(S, handler) {

    /*
      target glyph          source glyph
      favored               disfavored
      `sim/has-source`
      `sim/is-target`
                            `sim/is-source`
                            `sim/has-target`
     */
    var $, $add_intervals, $async, $collect_tags, PS, SIMS, pipeline, source;
    PS = require('pipestreams');
    $ = PS.$, $async = PS.$async;
    $add_intervals = (function(_this) {
      return function() {
        return $('null', function(phrase, send) {
          var ctag, mtag, obj, obj1, otag, source_cid, source_glyph, target_cid, target_glyph;
          if (phrase == null) {
            return handler(null, S);
          }
          send(phrase);
          target_glyph = phrase[0], otag = phrase[1], source_glyph = phrase[2];
          if (!(MKNCR.is_inner_glyph(target_glyph))) {
            return;
          }
          if (!(MKNCR.is_inner_glyph(source_glyph))) {
            return;
          }
          source_cid = MKNCR.as_cid(source_glyph);
          target_cid = MKNCR.as_cid(target_glyph);
          otag = otag.replace(/^sim\//, '');
          mtag = "sim/target/" + otag;
          ctag = "sim sim/has-target sim/is-source sim/has-target/" + otag + " sim/is-source/" + otag + " sim/" + otag;
          S.collector.push((
            obj = {
              lo: source_cid,
              hi: source_cid,
              sim: mtag
            },
            obj["" + mtag] = target_glyph,
            obj.tag = ctag,
            obj
          ));
          mtag = "sim/source/" + otag;
          ctag = "sim sim/has-source sim/is-target sim/has-source/" + otag + " sim/is-target/" + otag + " sim/" + otag;
          S.collector.push((
            obj1 = {
              lo: target_cid,
              hi: target_cid,
              sim: mtag
            },
            obj1["" + mtag] = source_glyph,
            obj1.tag = ctag,
            obj1
          ));
          return null;
        });
      };
    })(this);
    $collect_tags = (function(_this) {
      return function() {
        var tags;
        tags = new Set();
        return $('null', function(record) {
          if (record != null) {
            tags.add(record['tag']);
          } else {
            debug('3334', tags);
          }
          return null;
        });
      };
    })(this);
    SIMS = require('../../mojikura/lib/read-sims');
    source = SIMS.new_readstream();
    pipeline = [];
    pipeline.push(source);
    pipeline.push($add_intervals());
    pipeline.push(PS.$drain());
    PS.pull.apply(PS, pipeline);
    return null;
  };

  block_style_as_tex = function(block_style) {
    return "\\" + block_style + "{}";
  };

  glyph_style_as_tex = function(glyph, glyph_style) {

    /* NOTE this code replaces parts of `tex-writer-typofix._style_chr` */

    /* TAINT using `prPushRaise` here in place of `tfPushRaise` because it gives better
    results
     */
    var R, ref, ref1, ref2, ref3, rpl_chr, rpl_cmd, rpl_push, rpl_raise, use_tfpushraise;
    use_tfpushraise = false;
    R = [];
    R.push("{");
    rpl_push = (ref = glyph_style['push']) != null ? ref : null;
    rpl_raise = (ref1 = glyph_style['raise']) != null ? ref1 : null;
    rpl_chr = (ref2 = glyph_style['glyph']) != null ? ref2 : glyph;
    rpl_cmd = (ref3 = glyph_style['cmd']) != null ? ref3 : null;
    if (use_tfpushraise) {
      if ((rpl_push != null) && (rpl_raise != null)) {
        R.push("\\prPushRaise{" + rpl_push + "}{" + rpl_raise + "}{");
      } else if (rpl_push != null) {
        R.push("\\prPush{" + rpl_push + "}{");
      } else if (rpl_raise != null) {
        R.push("\\prRaise{" + rpl_raise + "}{");
      }
    } else {
      if ((rpl_push != null) && (rpl_raise != null)) {
        R.push("\\tfPushRaise{" + rpl_push + "}{" + rpl_raise + "}");
      } else if (rpl_push != null) {
        R.push("\\tfPush{" + rpl_push + "}");
      } else if (rpl_raise != null) {
        R.push("\\tfRaise{" + rpl_raise + "}");
      }
    }
    if (rpl_cmd != null) {
      R.push("\\" + rpl_cmd + "{}");
    }
    R.push(rpl_chr);
    if (use_tfpushraise && ((rpl_push != null) || (rpl_raise != null))) {
      R.push("}");
    }
    R.push("}");
    R = R.join('');
    return R;
  };

  main = function() {
    if (module.parent != null) {
      return read_cache();
    }
    return rewrite_cache();
  };

  main();

}).call(this);

//# sourceMappingURL=main.js.map
