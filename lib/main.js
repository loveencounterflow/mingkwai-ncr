// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, FS, ISL, MKNCR, NCR, PATH, _get_aggregate, _populate_isl_with_sims, badge, block_style_as_tex, debug, demo, demo_2, echo, get_file_age, glyph_style_as_tex, info, log, populate_isl, populate_isl_with_tex_formats, read_cache, rewrite_cache, rpr, step, u, urge;

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MINGKWAI-NCR';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  NCR = require('ncr');

  module.exports = MKNCR = NCR._copy_library('xncr');

  ISL = MKNCR._ISL;

  u = MKNCR.unicode_isl;

  get_file_age = function(path, allow_missing) {
    var error, error1, stats;
    if (allow_missing == null) {
      allow_missing = false;
    }
    try {
      stats = FS.statSync(path);
    } catch (error1) {
      error = error1;
      if (!(allow_missing && error['code'] === 'ENOENT')) {
        throw error;
      }
      return -Infinity;
    }
    return +stats.mtime;
  };

  populate_isl = function(handler) {
    var S, cache_age, must_rewrite_cache, source_age;
    S = {
      paths: {
        cache: PATH.resolve(__dirname, '../data/isl-entries.json'),
        mkts_options: PATH.resolve(__dirname, '../../mingkwai-typesetter/options.js'),
        jizura_datasources: PATH.resolve(__dirname, '../../../jizura-datasources/data/flat-files/')
      }
    };
    S.paths.strokeorders = PATH.resolve(S.paths.jizura_datasources, 'shape/shape-strokeorder-zhaziwubifa.txt');
    source_age = -Infinity;
    source_age = Math.max(source_age, get_file_age(S.paths.mkts_options));
    source_age = Math.max(source_age, get_file_age(S.paths.strokeorders));
    cache_age = get_file_age(S.paths.cache, true);
    must_rewrite_cache = cache_age < source_age;

    /*
    must_rewrite_cache  = yes
     */
    if (must_rewrite_cache) {
      rewrite_cache(S, handler);
    } else {
      read_cache(S, handler);
    }
    return null;
  };

  read_cache = function(S, handler) {
    var entry, i, len, ref;
    ref = require(S.paths.cache);
    for (i = 0, len = ref.length; i < len; i++) {
      entry = ref[i];
      ISL.add(u, entry);
    }
    return handler();
  };

  rewrite_cache = function(S, handler) {
    urge("rewriting cache");
    S.collector = [];
    step(function*(resume) {
      var entry, i, len, ref;
      debug('32118', S.collector.length);
      (yield populate_isl_with_tex_formats(S, resume));
      debug('32118', S.collector.length);

      /*
      yield _populate_isl_with_sims         S, resume
      debug '32118', S.collector.length
       */
      FS.writeFileSync(S.paths.cache, JSON.stringify(S.collector, null, '  '));
      ref = S.collector;
      for (i = 0, len = ref.length; i < len; i++) {
        entry = ref[i];
        ISL.add(u, entry);
      }
      return handler();
    });
    return null;
  };

  populate_isl_with_tex_formats = function(S, handler) {
    var block_command, entry, glyph_styles, hi, i, key, len, lo, mkts_options, ref, rsg, tex, tex_command_by_rsgs;
    mkts_options = require(S.paths.mkts_options);
    tex_command_by_rsgs = mkts_options['tex']['tex-command-by-rsgs'];
    glyph_styles = mkts_options['tex']['glyph-styles'];
    debug((function() {
      var results;
      results = [];
      for (key in u['indexes']) {
        results.push(key);
      }
      return results;
    })());
    for (rsg in tex_command_by_rsgs) {
      block_command = tex_command_by_rsgs[rsg];
      ref = ISL.find_entries(u, 'rsg', rsg);
      for (i = 0, len = ref.length; i < len; i++) {
        entry = ref[i];

        /* Note: must push new entries to collector, cannot recycle existing ones here */
        lo = entry.lo, hi = entry.hi, tex = entry.tex;
        if (tex == null) {
          tex = {};
        }
        tex['block'] = block_style_as_tex(block_command);
      }
      S.collector.push({
        lo: lo,
        hi: hi,
        tex: tex
      });
    }

    /* TAINT must resolve (X)NCRs */

    /*
    for glyph, glyph_style of glyph_styles
      cid             = MKNCR.as_cid glyph
      glyph_style_tex = glyph_style_as_tex glyph, glyph_style
      S.collector.push { lo: cid, hi: cid, tex: { codepoint: glyph_style_tex, }, }
     */
    return handler();
  };

  _populate_isl_with_sims = function(S, handler) {
    var $add_intervals, $collect_tags, S1, SIMS, input;
    $add_intervals = (function(_this) {
      return function() {
        return $(function(record) {
          var ctag, mtag, obj, obj1, otag, source_cid, source_glyph, target_cid, target_glyph;
          source_glyph = record.source_glyph, target_glyph = record.target_glyph;
          source_cid = MKNCR.as_cid(record['source_glyph']);
          target_cid = MKNCR.as_cid(record['target_glyph']);
          otag = record['tag'];
          mtag = "sim/target/" + otag;
          ctag = "sim sim/has-target sim/is-source sim/has-target/" + otag + " sim/is-source/" + otag + " sim/" + otag;
          S.collector.push((
            obj = {
              lo: source_cid,
              hi: source_cid
            },
            obj["" + mtag] = target_glyph,
            obj.tag = ctag,
            obj
          ));
          mtag = "sim/source/" + otag;
          ctag = "sim sim/has-source sim/is-target sim/has-source/" + otag + " sim/is-target/" + otag + " sim/" + otag;
          S.collector.push((
            obj1 = {
              lo: target_cid,
              hi: target_cid
            },
            obj1["" + mtag] = source_glyph,
            obj1.tag = ctag,
            obj1
          ));
          return null;
        });
      };
    })(this);
    $collect_tags = (function(_this) {
      return function() {
        var tags;
        tags = new Set;
        return $('null', function(record) {
          if (record != null) {
            tags.add(record['tag']);
          } else {
            debug('3334', tags);
          }
          return null;
        });
      };
    })(this);
    SIMS = require('../../jizura-db-feeder/lib/feed-sims');
    S1 = {};
    S1.db = null;
    S1.source_home = S.paths.jizura_datasources;
    input = SIMS.new_sim_readstream(S1, {
      filter: true
    });
    input.pipe($add_intervals()).pipe($('finish', handler));
    return null;
  };

  block_style_as_tex = function(block_style) {
    return "\\" + block_style;
  };

  glyph_style_as_tex = function(glyph, glyph_style) {

    /* NOTE this code replaces parts of `tex-writer-typofix._style_chr` */

    /* TAINT using `prPushRaise` here in place of `tfPushRaise` because it gives better
    results
     */
    var R, ref, ref1, ref2, ref3, rpl_chr, rpl_cmd, rpl_push, rpl_raise, use_tfpushraise;
    use_tfpushraise = false;
    R = [];
    R.push("{");
    rpl_push = (ref = glyph_style['push']) != null ? ref : null;
    rpl_raise = (ref1 = glyph_style['raise']) != null ? ref1 : null;
    rpl_chr = (ref2 = glyph_style['glyph']) != null ? ref2 : glyph;
    rpl_cmd = (ref3 = glyph_style['cmd']) != null ? ref3 : null;
    if (use_tfpushraise) {
      if ((rpl_push != null) && (rpl_raise != null)) {
        R.push("\\prPushRaise{" + rpl_push + "}{" + rpl_raise + "}{");
      } else if (rpl_push != null) {
        R.push("\\prPush{" + rpl_push + "}{");
      } else if (rpl_raise != null) {
        R.push("\\prRaise{" + rpl_raise + "}{");
      }
    } else {
      if ((rpl_push != null) && (rpl_raise != null)) {
        R.push("\\tfPushRaise{" + rpl_push + "}{" + rpl_raise + "}");
      } else if (rpl_push != null) {
        R.push("\\tfPush{" + rpl_push + "}");
      } else if (rpl_raise != null) {
        R.push("\\tfRaise{" + rpl_raise + "}");
      }
    }
    if (rpl_cmd != null) {
      R.push("\\" + rpl_cmd + "{}");
    }
    R.push(rpl_chr);
    if (use_tfpushraise && ((rpl_push != null) || (rpl_raise != null))) {
      R.push("}");
    }
    R.push("}");
    R = R.join('');
    return R;
  };

  demo = function(handler) {
    step((function(_this) {
      return function*(resume) {
        var aggregate, description, glyph, i, j, k, len, len1, len2, reducers, ref, ref1, ref2, ref3, ref4, ref5, sim_tag, sim_tags, text, value;
        (yield populate_isl(resume));

        /* TAINT tags should be collected during SIM reading */
        sim_tags = ['sim/source/global', 'sim/source/components', 'sim/source/components/search', 'sim/source/false-identity', 'sim/target/global', 'sim/target/components', 'sim/target/components/search', 'sim/target/false-identity'];
        reducers = {
          '*': 'skip',
          tag: 'tag',
          rsg: 'assign',
          tex: function(values, context) {

            /* TAINT should be a standard reducer */
            var R, i, len, name, sub_value, value;
            R = {};
            for (i = 0, len = values.length; i < len; i++) {
              value = values[i];
              for (name in value) {
                sub_value = value[name];
                R[name] = sub_value;
              }
            }
            return R;
          }
        };
        for (i = 0, len = sim_tags.length; i < len; i++) {
          sim_tag = sim_tags[i];
          reducers[sim_tag] = 'list';
        }
        aggregate = _get_aggregate(MKNCR, reducers);
        text = '龵⿸釒金𤴔丨亅㐅乂';
        text = '釒';
        ref = Array.from(text);
        for (j = 0, len1 = ref.length; j < len1; j++) {
          glyph = ref[j];
          description = aggregate(glyph);
          info(glyph);
          urge('  tag:', ((ref1 = description['tag']) != null ? ref1 : ['-/-']).join(', '));
          urge('  rsg:', description['rsg']);
          for (k = 0, len2 = sim_tags.length; k < len2; k++) {
            sim_tag = sim_tags[k];
            if ((value = description[sim_tag]) == null) {
              continue;
            }
            urge("  " + sim_tag + ":", value);
          }
          urge('  blk:', (ref2 = (ref3 = description['tex']) != null ? ref3['block'] : void 0) != null ? ref2 : '-/-');
          urge('  cp: ', (ref4 = (ref5 = description['tex']) != null ? ref5['codepoint'] : void 0) != null ? ref4 : '-/-');
        }
        return handler();
      };
    })(this));
    return null;
  };

  demo_2 = function() {
    var cid, entry, entry_tag, i, j, len, len1, ref, search_tag, source_fncr, source_glyph, source_glyph_info, tag, tags, target_fncr, target_glyph, target_glyph_info;
    tags = ['global', 'components', 'components/search', 'false-identity'];
    for (i = 0, len = tags.length; i < len; i++) {
      tag = tags[i];
      echo(tag);
      search_tag = "sim/is-target/" + tag;
      entry_tag = "sim/source/" + tag;
      ref = MKNCR._ISL.find_entries(u, 'tag', search_tag);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        entry = ref[j];

        /* Silently assuming that all relevant entries represent single-character intervals */
        target_glyph_info = MKNCR.analyze((cid = entry['lo']));
        target_glyph = target_glyph_info['uchr'];
        target_fncr = target_glyph_info['fncr'];
        source_glyph = entry[entry_tag];
        source_glyph_info = MKNCR.analyze(source_glyph);
        source_fncr = source_glyph_info['fncr'];
        echo(target_fncr, target_glyph, '<-', source_fncr, source_glyph);
      }
    }
    return null;
  };

  _get_aggregate = function(ncr, reducers) {
    var cache;
    cache = {};
    return (function(_this) {
      return function(glyph) {
        var R;
        if ((R = cache[glyph]) != null) {
          return R;
        }
        return cache[glyph] = ncr._ISL.aggregate(ncr.unicode_isl, glyph, reducers);
      };
    })(this);
  };

  if (module.parent == null) {
    demo(function(error) {
      if (error != null) {
        throw error;
      }
    });
  }

}).call(this);

//# sourceMappingURL=main.js.map
