// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, FS, ISL, MKNCR, NCR, PATH, badge, block_style_as_tex, debug, echo, get_file_time, glyph_style_as_tex, help, info, log, new_state, populate_isl, populate_isl_with_extra_data, populate_isl_with_sims, populate_isl_with_tex_formats, read_cache, rewrite_cache, rpr, sim_cache_is_out_of_date, step, u, urge, warn,
    slice = [].slice;

  PATH = require('path');

  FS = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MINGKWAI-NCR';

  log = CND.get_logger('plain', badge);

  debug = CND.get_logger('debug', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  echo = CND.echo.bind(CND);

  D = require('pipedreams');

  $ = D.$, $async = D.$async;

  step = require('coffeenode-suspend').step;

  NCR = require('ncr');

  module.exports = MKNCR = NCR._copy_library('xncr');

  ISL = MKNCR._ISL;

  u = MKNCR.unicode_isl;

  MKNCR.is_inner_glyph = function(glyph) {
    var ref;
    return (ref = this.as_csg(glyph)) === 'u' || ref === 'jzr';
  };

  MKNCR.jzr_as_uchr = function(glyph) {
    if ((this.as_csg(glyph)) === 'jzr') {
      return this.as_uchr(glyph);
    }
    return glyph;
  };

  MKNCR.normalize = function(glyph) {
    var cid, csg, rsg;
    throw new Error("XNCHR.normalize is deprecated");
    rsg = this.as_rsg(glyph);
    cid = this.as_cid(glyph);
    csg = rsg === 'u-pua' ? 'jzr' : 'u';
    return this.chr_from_cid_and_csg(cid, csg);
  };

  MKNCR.normalize_to_xncr = function(glyph) {
    var cid, csg;
    throw new Error("do we need this method?");
    cid = this.as_cid(glyph);
    csg = (this.as_rsg(glyph)) === 'u-pua' ? 'jzr' : this.as_csg(glyph);
    return this.chr_from_cid_and_csg(cid, csg);
  };

  MKNCR.normalize_to_pua = function(glyph) {
    var cid, csg;
    throw new Error("do we need this method?");
    cid = this.as_cid(glyph);
    csg = this.as_csg(glyph);
    if (csg === 'jzr') {
      csg = 'u';
    }
    return this.chr_from_cid_and_csg(cid, csg);
  };

  (function(_this) {
    return (function() {
      var aggregate, i, len, recipe, sim_tag, sim_tags;
      sim_tags = ['sim/source/global', 'sim/source/components', 'sim/source/components/search', 'sim/source/false-identity', 'sim/target/global', 'sim/target/components', 'sim/target/components/search', 'sim/target/false-identity'];
      recipe = {
        fallback: 'skip',
        fields: {
          tag: 'tag',
          rsg: 'assign',
          tex: function(values, context) {

            /* TAINT should be a standard reducer */
            var R, i, len, name, sub_value, value;
            R = {};
            for (i = 0, len = values.length; i < len; i++) {
              value = values[i];
              for (name in value) {
                sub_value = value[name];
                R[name] = sub_value;
              }
            }
            return R;
          }
        }
      };
      for (i = 0, len = sim_tags.length; i < len; i++) {
        sim_tag = sim_tags[i];
        recipe['fields'][sim_tag] = 'list';
      }

      /* TAINT experimental */
      aggregate = ISL.aggregate.use(u, recipe, {
        memoize: true
      });
      (function() {
        var cache;
        cache = {};
        return MKNCR.describe = function() {
          var A, P, R, id, key, value;
          P = 1 <= arguments.length ? slice.call(arguments, 0) : [];

          /* TAINT what about gaiji? */
          id = JSON.stringify(P);
          if ((R = cache[id]) != null) {
            return R;
          }
          A = this.analyze.apply(this, P);
          R = aggregate(A['cid']);
          for (key in A) {
            value = A[key];
            R[key] = value;
          }
          cache[id] = R;
          return R;
        };
      })();
      return null;
    });
  })(this)();

  get_file_time = function(path, allow_missing) {
    var error, error1, stats;
    if (allow_missing == null) {
      allow_missing = false;
    }
    try {
      stats = FS.statSync(path);
    } catch (error1) {
      error = error1;
      if (!(allow_missing && error['code'] === 'ENOENT')) {
        throw error;
      }
      return -Infinity;
    }
    return +stats.mtime;
  };

  new_state = function() {
    var R;
    R = {};
    R.paths = {};
    R.paths.cache = PATH.resolve(__dirname, '../data/isl-entries.json');
    R.paths.mkts_options = PATH.resolve(__dirname, '../../mingkwai-typesetter/lib/options.js');
    R.paths.jizura_datasources = PATH.resolve(__dirname, '../../../jizura-datasources/data/flat-files/');
    R.paths.sims = PATH.resolve(R.paths.jizura_datasources, 'shape/shape-similarity-identity.txt');
    return R;
  };

  sim_cache_is_out_of_date = function(S) {
    var cache_time, source_time;
    if (S == null) {
      S = null;
    }
    if (S == null) {
      S = new_state();
    }
    source_time = -Infinity;
    source_time = Math.max(source_time, get_file_time(S.paths.mkts_options));
    source_time = Math.max(source_time, get_file_time(S.paths.sims));
    cache_time = get_file_time(S.paths.cache, true);
    return cache_time < source_time;
  };

  populate_isl = function(handler) {
    var S, cache_path, must_rewrite_cache;
    S = new_state();
    must_rewrite_cache = sim_cache_is_out_of_date(S);
    if (must_rewrite_cache) {
      if ((module.parent != null) && (handler == null)) {
        cache_path = PATH.relative(process.cwd(), S.paths.cache);
        warn("cache file");
        warn("" + cache_path);
        warn("is out of date");
        urge("run the command");
        urge(CND.white("node " + (PATH.relative(process.cwd(), __filename))));
        urge("to rebuild " + cache_path);
      } else {
        rewrite_cache(S, handler);
      }
    } else {
      if (handler == null) {
        handler = function(error) {
          if (error != null) {
            throw error;
          }
        };
      }
      read_cache(S, handler);
    }
    return null;
  };

  read_cache = function(S, handler) {
    var entry, i, len, ref;
    ref = require(S.paths.cache);
    for (i = 0, len = ref.length; i < len; i++) {
      entry = ref[i];
      ISL.add(u, entry);
    }
    if (handler != null) {
      handler(null, S);
    }
    return null;
  };

  rewrite_cache = function(S, handler) {
    help("rewriting cache");
    S.collector = [];
    step(function*(resume) {
      var entry, i, len, ref;
      (yield populate_isl_with_tex_formats(S, resume));
      (yield populate_isl_with_sims(S, resume));
      (yield populate_isl_with_extra_data(S, resume));
      FS.writeFileSync(S.paths.cache, JSON.stringify(S.collector, null, '  '));
      ref = S.collector;
      for (i = 0, len = ref.length; i < len; i++) {
        entry = ref[i];
        ISL.add(u, entry);
      }
      if (handler != null) {
        return handler(null, S);
      }
    });
    return null;
  };

  populate_isl_with_tex_formats = function(S, handler) {
    var block_command, cid, cjk_rsgs, entry, fallback_command, glyph, glyph_style, glyph_style_tex, glyph_styles, hi, i, j, k, len, len1, len2, lo, mkts_options, ref, ref1, ref2, rsg, tex, tex_command_by_rsgs;
    mkts_options = require(S.paths.mkts_options);
    tex_command_by_rsgs = mkts_options['tex']['tex-command-by-rsgs'];
    glyph_styles = mkts_options['tex']['glyph-styles'];
    cjk_rsgs = mkts_options['tex']['cjk-rsgs'];
    fallback_command = block_style_as_tex((ref = tex_command_by_rsgs['fallback']) != null ? ref : 'mktsRsgFb');
    S.collector.push({
      lo: 0x000000,
      hi: 0x10ffff,
      tex: {
        block: fallback_command
      }
    });
    for (rsg in tex_command_by_rsgs) {
      block_command = tex_command_by_rsgs[rsg];
      if (rsg === 'fallback') {
        continue;
      }
      ref1 = ISL.find_entries(u, 'rsg', rsg);
      for (i = 0, len = ref1.length; i < len; i++) {
        entry = ref1[i];

        /* Note: must push new entries to collector, cannot recycle existing ones here */
        lo = entry.lo, hi = entry.hi, tex = entry.tex;
        if (tex == null) {
          tex = {};
        }
        tex['block'] = block_style_as_tex(block_command);
        S.collector.push({
          lo: lo,
          hi: hi,
          tex: tex
        });
      }
    }

    /* TAINT must resolve (X)NCRs */
    for (glyph in glyph_styles) {
      glyph_style = glyph_styles[glyph];
      cid = MKNCR.as_cid(glyph);
      glyph_style_tex = glyph_style_as_tex(glyph, glyph_style);
      S.collector.push({
        lo: cid,
        hi: cid,
        tex: {
          codepoint: glyph_style_tex
        }
      });
    }
    for (j = 0, len1 = cjk_rsgs.length; j < len1; j++) {
      rsg = cjk_rsgs[j];
      ref2 = ISL.find_entries(u, 'rsg', rsg);
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        entry = ref2[k];

        /* Note: must push new entries to collector, cannot recycle existing ones here */
        lo = entry.lo, hi = entry.hi;
        S.collector.push({
          lo: lo,
          hi: hi,
          tag: ['cjk']
        });
      }
    }
    return handler(null, S);
  };

  populate_isl_with_extra_data = function(S, handler) {
    var chr, hi, i, len, lo, ref;
    ref = Array.from('\x20\n\r\t');
    for (i = 0, len = ref.length; i < len; i++) {
      chr = ref[i];
      lo = hi = MKNCR.as_cid(chr);
      S.collector.push({
        lo: lo,
        hi: hi,
        tag: ['ascii-whitespace']
      });
    }
    return handler(null, S);
  };

  populate_isl_with_sims = function(S, handler) {
    var $add_intervals, $collect_tags, JZRDBF_U, S1, SIMS, input;
    debug('33241', 'populate_isl_with_sims');
    $add_intervals = (function(_this) {
      return function() {
        return $(function(record) {
          var ctag, mtag, obj, obj1, otag, source_cid, source_glyph, target_cid, target_glyph;
          source_glyph = record.source_glyph, target_glyph = record.target_glyph;
          source_cid = MKNCR.as_cid(record['source_glyph']);
          target_cid = MKNCR.as_cid(record['target_glyph']);
          otag = record['tag'];
          mtag = "sim/target/" + otag;
          ctag = "sim sim/has-target sim/is-source sim/has-target/" + otag + " sim/is-source/" + otag + " sim/" + otag;
          S.collector.push((
            obj = {
              lo: source_cid,
              hi: source_cid
            },
            obj["" + mtag] = target_glyph,
            obj.tag = ctag,
            obj
          ));
          mtag = "sim/source/" + otag;
          ctag = "sim sim/has-source sim/is-target sim/has-source/" + otag + " sim/is-target/" + otag + " sim/" + otag;
          S.collector.push((
            obj1 = {
              lo: target_cid,
              hi: target_cid
            },
            obj1["" + mtag] = source_glyph,
            obj1.tag = ctag,
            obj1
          ));
          return null;
        });
      };
    })(this);
    $collect_tags = (function(_this) {
      return function() {
        var tags;
        tags = new Set;
        return $('null', function(record) {
          if (record != null) {
            tags.add(record['tag']);
          } else {
            debug('3334', tags);
          }
          return null;
        });
      };
    })(this);
    SIMS = require('../../jizura-db-feeder/lib/feed-sims');
    JZRDBF_U = require('../../jizura-db-feeder/lib/utilities');
    S1 = JZRDBF_U.new_state();
    S1.db = null;
    input = SIMS.new_sim_readstream(S1, {
      filter: true
    });
    input.pipe($add_intervals()).pipe($('finish', function() {
      return handler(null, S);
    }));
    return null;
  };

  block_style_as_tex = function(block_style) {
    return "\\" + block_style + "{}";
  };

  glyph_style_as_tex = function(glyph, glyph_style) {

    /* NOTE this code replaces parts of `tex-writer-typofix._style_chr` */

    /* TAINT using `prPushRaise` here in place of `tfPushRaise` because it gives better
    results
     */
    var R, ref, ref1, ref2, ref3, rpl_chr, rpl_cmd, rpl_push, rpl_raise, use_tfpushraise;
    use_tfpushraise = false;
    R = [];
    R.push("{");
    rpl_push = (ref = glyph_style['push']) != null ? ref : null;
    rpl_raise = (ref1 = glyph_style['raise']) != null ? ref1 : null;
    rpl_chr = (ref2 = glyph_style['glyph']) != null ? ref2 : glyph;
    rpl_cmd = (ref3 = glyph_style['cmd']) != null ? ref3 : null;
    if (use_tfpushraise) {
      if ((rpl_push != null) && (rpl_raise != null)) {
        R.push("\\prPushRaise{" + rpl_push + "}{" + rpl_raise + "}{");
      } else if (rpl_push != null) {
        R.push("\\prPush{" + rpl_push + "}{");
      } else if (rpl_raise != null) {
        R.push("\\prRaise{" + rpl_raise + "}{");
      }
    } else {
      if ((rpl_push != null) && (rpl_raise != null)) {
        R.push("\\tfPushRaise{" + rpl_push + "}{" + rpl_raise + "}");
      } else if (rpl_push != null) {
        R.push("\\tfPush{" + rpl_push + "}");
      } else if (rpl_raise != null) {
        R.push("\\tfRaise{" + rpl_raise + "}");
      }
    }
    if (rpl_cmd != null) {
      R.push("\\" + rpl_cmd + "{}");
    }
    R.push(rpl_chr);
    if (use_tfpushraise && ((rpl_push != null) || (rpl_raise != null))) {
      R.push("}");
    }
    R.push("}");
    R = R.join('');
    return R;
  };

  if (module.parent != null) {

    /* If this module is `require`d from another module, run `populate_isl` *without* callback. This will
    succeed if cache is present and up to date; it will fail with a helpful message otherwise.
     */
    populate_isl();
  } else {

    /* If this module is run as a script, rebuild the cache when necessary: */
    populate_isl(function(error, S) {
      if (error != null) {
        throw error;
      }
      help("" + S.paths.cache);
      help("is up to date");
      return null;
    });
  }

}).call(this);

//# sourceMappingURL=main.js.map
