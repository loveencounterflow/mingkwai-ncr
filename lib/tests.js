// Generated by CoffeeScript 1.12.4
(function() {
  var CND, ISL, MKNCR, alert, badge, debug, demo_2, echo, help, include, info, log, rpr, step, test, u, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'MINGKWAI-NCR/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  step = require('coffeenode-suspend').step;

  MKNCR = require('./main');

  ISL = MKNCR._ISL;

  u = MKNCR.unicode_isl;

  this._prune = function() {
    var name, ref, value;
    ref = this;
    for (name in ref) {
      value = ref[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  this._main = function() {
    return test(this, {
      'timeout': 3000
    });
  };

  this["demo"] = function(T) {
    var cid, glyph, i, len, ref;
    ref = MKNCR.chrs_from_text("《🖹");
    for (i = 0, len = ref.length; i < len; i++) {
      glyph = ref[i];
      cid = MKNCR.as_cid(glyph);
      debug(glyph, ISL.aggregate(u, cid));
    }
    return null;
  };

  this["aggregate"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, recipe, ref, result;
    u = MKNCR.unicode_isl;
    ISL = MKNCR._ISL;
    probes_and_matchers = [
      [
        "q", {
          "tag": ["assigned"],
          "rsg": "u-latn"
        }
      ], [
        "里", {
          "tag": ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"],
          "rsg": "u-cjk"
        }
      ], [
        "䊷", {
          "tag": ["assigned", "ideograph", "cjk"],
          "rsg": "u-cjk-xa"
        }
      ], [
        "《", {
          "tag": ["assigned", "punctuation", "cjk"],
          "rsg": "u-cjk-sym"
        }
      ], [
        "🖹", {
          "tag": ["assigned"]
        }
      ], [
        "🛷", {
          "tag": ["unassigned"]
        }
      ], [
        887, {
          "tag": ["assigned"],
          "rsg": "u-grek"
        }
      ], [
        888, {
          "tag": ["unassigned"],
          "rsg": "u-grek"
        }
      ], [
        889, {
          "tag": ["unassigned"],
          "rsg": "u-grek"
        }
      ], [
        890, {
          "tag": ["assigned"],
          "rsg": "u-grek"
        }
      ]
    ];
    recipe = {
      fallback: 'skip',
      fields: {
        'tag': 'tag',
        'rsg': 'assign'
      }
    };
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
      result = ISL.aggregate(u, probe, recipe);
      T.eq(result, matcher);
    }
    return null;
  };

  this["SIMs, TeX formats"] = function(T) {
    var description, i, j, len, len1, matcher, probe, probes_and_matchers, recipe, ref, sim_tag, sim_tags;
    sim_tags = ['sim/source/global', 'sim/source/components', 'sim/source/components/search', 'sim/source/false-identity', 'sim/target/global', 'sim/target/components', 'sim/target/components/search', 'sim/target/false-identity'];
    recipe = {
      fallback: 'skip',
      fields: {
        tag: 'tag',
        rsg: 'assign',
        tex: function(values, context) {

          /* TAINT should be a standard reducer */
          var R, i, len, name, sub_value, value;
          R = {};
          for (i = 0, len = values.length; i < len; i++) {
            value = values[i];
            for (name in value) {
              sub_value = value[name];
              R[name] = sub_value;
            }
          }
          return R;
        }
      }
    };
    for (i = 0, len = sim_tags.length; i < len; i++) {
      sim_tag = sim_tags[i];
      recipe['fields'][sim_tag] = 'list';
    }
    probes_and_matchers = [
      [
        "龵", {
          "tag": ["assigned", "ideograph", "cjk"],
          "rsg": "u-cjk",
          "tex": {
            "block": "\\cn{}",
            "codepoint": "{\\tfRaise{-0.1}\\cnxBabel{}龵}"
          }
        }
      ], [
        "？", {
          "tag": ["assigned", "cjk"],
          "rsg": "u-halfull",
          "tex": {
            "block": "\\cn{}"
          }
        }
      ], [
        "⿸", {
          "tag": ["assigned", "cjk", "idl"],
          "rsg": "u-cjk-idc",
          "tex": {
            "block": "\\mktsRsgFb{}",
            "codepoint": "{\\cnxJzr{}}"
          }
        }
      ], [
        "釒", {
          "tag": ["assigned", "ideograph", "cjk", "sim", "sim/has-target", "sim/is-source", "sim/has-target/components", "sim/is-source/components", "sim/components"],
          "rsg": "u-cjk",
          "sim/target/components": ["金"],
          "tex": {
            "block": "\\cn{}",
            "codepoint": "{\\tfPush{0.4}釒}"
          }
        }
      ], [
        "金", {
          "tag": ["assigned", "ideograph", "cjk", "sim/has-source/global", "sim/is-target/global", "sim/global", "sim", "sim/has-source", "sim/is-target", "sim/has-source/components", "sim/is-target/components", "sim/components"],
          "rsg": "u-cjk",
          "sim/source/global": ["金", "⾦"],
          "sim/source/components": ["釒"],
          "tex": {
            "block": "\\cn{}"
          }
        }
      ], [
        "𤴔", {
          "tag": ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"],
          "rsg": "u-cjk-xb",
          "sim/source/global": ["⺪"],
          "tex": {
            "block": "\\cnxb{}",
            "codepoint": "{\\cnxBabel{}𤴔}"
          }
        }
      ], [
        "丨", {
          "tag": ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"],
          "rsg": "u-cjk",
          "sim/source/global": ["〡", "⼁", "㇑"],
          "tex": {
            "block": "\\cn{}"
          }
        }
      ], [
        "亅", {
          "tag": ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"],
          "rsg": "u-cjk",
          "sim/source/global": ["⼅", "㇚"],
          "tex": {
            "block": "\\cn{}"
          }
        }
      ], [
        "㐅", {
          "tag": ["assigned", "ideograph", "cjk", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global", "sim", "sim/has-target", "sim/is-source", "sim/has-target/components", "sim/is-source/components", "sim/components"],
          "rsg": "u-cjk-xa",
          "sim/source/global": ["〤"],
          "sim/target/components": ["乂"],
          "tex": {
            "block": "\\cnxa{}"
          }
        }
      ], [
        "乂", {
          "tag": ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/components", "sim/is-target/components", "sim/components"],
          "rsg": "u-cjk",
          "sim/source/components": ["㐅", "乄"],
          "tex": {
            "block": "\\cn{}"
          }
        }
      ]
    ];
    for (j = 0, len1 = probes_and_matchers.length; j < len1; j++) {
      ref = probes_and_matchers[j], probe = ref[0], matcher = ref[1];
      description = ISL.aggregate(u, probe, recipe);
      T.eq(description, matcher);

      /*
      urge '  tag:', ( description[ 'tag' ] ? [ '-/-' ] ).join ', '
      urge '  rsg:', description[ 'rsg' ]
      for sim_tag in sim_tags
        continue unless ( value = description[ sim_tag ] )?
        urge "  #{sim_tag}:", value
      urge '  blk:', description[ 'tex' ]?[ 'block'     ] ? '-/-'
      urge '  cp: ', description[ 'tex' ]?[ 'codepoint' ] ? '-/-'
       */
    }
    return null;
  };

  this["descriptions (2)"] = function(T) {
    var csg, description, i, len, matcher, probe, probes_and_matchers, ref, result, tag, tex;
    probes_and_matchers = [
      [
        "⿲", [
          "u", ["assigned", "cjk", "idl"], {
            "block": "\\mktsRsgFb{}"
          }
        ]
      ], [
        "⿱", [
          "u", ["assigned", "cjk", "idl"], {
            "block": "\\mktsRsgFb{}",
            "codepoint": "{\\cnxJzr{}}"
          }
        ]
      ], [
        "木", [
          "u", ["assigned", "ideograph", "cjk", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"], {
            "block": "\\cn{}"
          }
        ]
      ], [
        "&#x1233;", [
          "u", ["assigned"], {
            "block": "\\mktsRsgFb{}"
          }
        ]
      ], [
        "&#x1234;", [
          "u", ["assigned"], {
            "block": "\\mktsRsgFb{}"
          }
        ]
      ], [
        "&#x1235;", [
          "u", ["assigned"], {
            "block": "\\mktsRsgFb{}"
          }
        ]
      ], ["&morohashi#x1234;", ["morohashi", ["assigned", "cjk", "ideograph"], void 0]], [
        "&#xe100;", [
          "jzr", ["assigned", "cjk", "ideograph"], {
            "block": "\\cnjzr{}"
          }
        ]
      ], [
        "&jzr#xe100;", [
          "jzr", ["assigned", "cjk", "ideograph"], {
            "block": "\\cnjzr{}"
          }
        ]
      ], [
        "&jzr#xe19f;", [
          "jzr", ["assigned", "cjk", "ideograph"], {
            "block": "\\cnjzr{}"
          }
        ]
      ]
    ];
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
      description = MKNCR.describe(probe);
      csg = description.csg, tag = description.tag, tex = description.tex;
      result = [csg, tag, tex];
      T.eq(result, matcher);
    }
    return null;
  };

  this["descriptions (3)"] = function(T) {
    var description_A, description_B;
    description_A = MKNCR.describe('&jzr#xe100;');
    description_B = MKNCR.describe(0xe100);
    urge(description_A);
    urge(description_B);
    T.eq(description_A, description_B);
    return null;
  };

  this["MojiKura get_set_of_CJK_ideograph_cids includes u-cjk-cmpi2"] = function(T) {
    var L, _, cid, cjk_cids, description, fncr, glyph, glyph_tags, glyph_tags_txt, i, j, len, len1, probes_and_matchers, ref, tag, tags;
    probes_and_matchers = [['u-cjk-cmpi2/2f801', '丸', ['cjk', 'ideograph']], ['u-cjk-cmpi1/f9ba', '了', ['cjk', 'ideograph']], ['u-cjk-rad1/2f08', '⼈', ['cjk', 'ideograph']], ['u-cjk/4e0d', '不', ['cjk', 'ideograph']], ['u-cjk-cmpi1/f967', '不', ['cjk', 'ideograph']], ['u-cjk-cmpi1/fa0e', '﨎', ['cjk', 'ideograph']], ['u-hang-syl-ae00', '글', ['cjk', 'korean', 'hangeul']], ['u-cjk-hira-3072', 'ひ', ['cjk', 'japanese', 'kana', 'hiragana']], ['u-cjk-sym/3001', '、', ['cjk', 'punctuation']], ['u-cjk-sym/3004', '〄', ['cjk', 'symbol']], ['u-cjk-sym/3005', '々', ['cjk', 'ideograph']], ['u-cjk-sym/3008', '〈', ['cjk', 'punctuation']], ['u-cjk-sym/3012', '〒', ['cjk', 'symbol']], ['u-cjk-sym/3013', '〓', ['cjk', 'ideograph', 'geta']], ['u-cjk-sym/3014', '〔', ['cjk', 'punctuation']], ['u-cjk-sym/3020', '〠', ['cjk', 'symbol']], ['u-cjk-sym/3021', '〡', ['cjk', 'ideograph']], ['u-cjk-sym/302a', '〪', ['cjk', 'punctuation']], ['u-cjk-sym/3031', '〱', ['cjk', 'kana']], ['u-cjk-sym/3036', '〶', ['cjk', 'symbol']], ['u-cjk-sym/3038', '〸', ['cjk', 'ideograph']], ['u-cjk-sym/303d', '〽', ['cjk', 'symbol']]];

    /* from `mojikura/src/utilities.coffee`: */
    L = {};
    L._set_from_facet = function(key, value) {
      var R, cid, hi, i, j, len, lo, ref, ref1, ref2, ref3;
      R = new Set();
      ref = MKNCR._ISL.find_entries(MKNCR.unicode_isl, key, value);
      for (i = 0, len = ref.length; i < len; i++) {
        ref1 = ref[i], lo = ref1.lo, hi = ref1.hi;
        for (cid = j = ref2 = lo, ref3 = hi; ref2 <= ref3 ? j <= ref3 : j >= ref3; cid = ref2 <= ref3 ? ++j : --j) {
          R.add(cid);
        }
      }
      return R;
    };

    /* from `mojikura/src/utilities.coffee`: */
    L.get_set_of_CJK_ideograph_cids = function() {
      var R;
      if ((R = L.get_set_of_CJK_ideograph_cids._R) != null) {
        return R;
      }
      return L.get_set_of_CJK_ideograph_cids._R = L._set_from_facet('tag', 'ideograph');
    };

    /* TAINT should also check above methods include expected glyphs */
    cjk_cids = L.get_set_of_CJK_ideograph_cids();
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref = probes_and_matchers[i], _ = ref[0], glyph = ref[1], tags = ref[2];
      cid = MKNCR.as_cid(glyph);
      description = MKNCR.describe(cid);
      fncr = description.fncr;
      glyph_tags = description['tag'];
      glyph_tags_txt = glyph_tags.join(', ');
      for (j = 0, len1 = tags.length; j < len1; j++) {
        tag = tags[j];
        if (indexOf.call(glyph_tags, tag) >= 0) {
          T.ok(true);
          help(fncr + " " + glyph + "   has tag " + tag + ": " + glyph_tags_txt);
        } else {
          urge(fncr + " " + glyph + " lacks tag " + tag + ": " + glyph_tags_txt);
          T.fail(fncr + " " + glyph + ": lacks tag " + tag);
        }
      }
    }
    return null;
  };

  this["jzr_as_xncr"] = function(T) {
    var glyph, glyph_r1, glyph_r2, glyph_uchr;
    glyph = "&jzr#xe234;";
    glyph_uchr = MKNCR.jzr_as_uchr(glyph);
    glyph_r1 = MKNCR.jzr_as_xncr(glyph);
    glyph_r2 = MKNCR.jzr_as_xncr(glyph_uchr);
    T.eq(glyph_uchr, '');
    T.eq(glyph_r1, '&jzr#xe234;');
    T.eq(glyph_r2, '&jzr#xe234;');
    return T.eq(MKNCR.jzr_as_xncr('x'), 'x');
  };

  demo_2 = function() {
    var cid, entry, entry_tag, i, j, len, len1, ref, search_tag, source_fncr, source_glyph, source_glyph_info, tag, tags, target_fncr, target_glyph, target_glyph_info;
    tags = ['global', 'components', 'components/search', 'false-identity'];
    for (i = 0, len = tags.length; i < len; i++) {
      tag = tags[i];
      echo(tag);
      search_tag = "sim/is-target/" + tag;
      entry_tag = "sim/source/" + tag;
      ref = MKNCR._ISL.find_entries(u, 'tag', search_tag);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        entry = ref[j];

        /* Silently assuming that all relevant entries represent single-character intervals */
        target_glyph_info = MKNCR.analyze((cid = entry['lo']));
        target_glyph = target_glyph_info['uchr'];
        target_fncr = target_glyph_info['fncr'];
        source_glyph = entry[entry_tag];
        source_glyph_info = MKNCR.analyze(source_glyph);
        source_fncr = source_glyph_info['fncr'];
        echo(target_fncr, target_glyph, '<-', source_fncr, source_glyph);
      }
    }
    return null;
  };

  if (module.parent == null) {
    include = ["aggregate", "SIMs, TeX formats", "jzr_as_xncr", "MojiKura get_set_of_CJK_ideograph_cids includes u-cjk-cmpi2", "descriptions (2)", "descriptions (3)"];
    this._prune();
    this._main();
  }

}).call(this);

//# sourceMappingURL=tests.js.map
