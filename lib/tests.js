// Generated by CoffeeScript 1.10.0
(function() {
  var CND, ISL, MKNCR, alert, badge, debug, demo_2, echo, help, include, info, log, rpr, step, test, u, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'MINGKWAI-NCR/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  step = require('coffeenode-suspend').step;

  MKNCR = require('./main');

  ISL = MKNCR._ISL;

  u = MKNCR.unicode_isl;

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  this._main = function() {
    return test(this, {
      'timeout': 3000
    });
  };

  this["demo"] = function(T) {
    var cid, glyph, i, len, ref;
    ref = MKNCR.chrs_from_text("ã€ŠðŸ–¹");
    for (i = 0, len = ref.length; i < len; i++) {
      glyph = ref[i];
      cid = MKNCR.as_cid(glyph);
      debug(glyph, ISL.aggregate(u, cid));
    }
    return null;
  };

  this["aggregate"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, recipe, ref, result;
    u = MKNCR.unicode_isl;
    ISL = MKNCR._ISL;
    probes_and_matchers = [
      [
        "q", {
          "tag": ["assigned"],
          "rsg": "u-latn"
        }
      ], [
        "é‡Œ", {
          "tag": ["assigned", "cjk", "ideograph", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"],
          "rsg": "u-cjk"
        }
      ], [
        "äŠ·", {
          "tag": ["assigned", "cjk", "ideograph"],
          "rsg": "u-cjk-xa"
        }
      ], [
        "ã€Š", {
          "tag": ["assigned", "cjk", "punctuation"],
          "rsg": "u-cjk-sym"
        }
      ], [
        "ðŸ–¹", {
          "tag": ["assigned"]
        }
      ], [
        "ðŸ›·", {
          "tag": ["unassigned"]
        }
      ], [
        887, {
          "tag": ["assigned"],
          "rsg": "u-grek"
        }
      ], [
        888, {
          "tag": ["unassigned"],
          "rsg": "u-grek"
        }
      ], [
        889, {
          "tag": ["unassigned"],
          "rsg": "u-grek"
        }
      ], [
        890, {
          "tag": ["assigned"],
          "rsg": "u-grek"
        }
      ]
    ];
    recipe = {
      fallback: 'skip',
      fields: {
        'tag': 'tag',
        'rsg': 'assign'
      }
    };
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
      result = ISL.aggregate(u, probe, recipe);
      debug('32771', JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["SIMs, TeX formats"] = function(T) {
    var description, i, j, k, len, len1, len2, matcher, probe, probes_and_matchers, recipe, ref, ref1, ref2, ref3, ref4, ref5, sim_tag, sim_tags, value;
    sim_tags = ['sim/source/global', 'sim/source/components', 'sim/source/components/search', 'sim/source/false-identity', 'sim/target/global', 'sim/target/components', 'sim/target/components/search', 'sim/target/false-identity'];
    recipe = {
      fallback: 'skip',
      fields: {
        tag: 'tag',
        rsg: 'assign',
        tex: function(values, context) {

          /* TAINT should be a standard reducer */
          var R, i, len, name, sub_value, value;
          R = {};
          for (i = 0, len = values.length; i < len; i++) {
            value = values[i];
            for (name in value) {
              sub_value = value[name];
              R[name] = sub_value;
            }
          }
          return R;
        }
      }
    };
    for (i = 0, len = sim_tags.length; i < len; i++) {
      sim_tag = sim_tags[i];
      recipe['fields'][sim_tag] = 'list';
    }
    probes_and_matchers = [
      [
        "é¾µ", {
          "tag": ["assigned", "cjk", "ideograph"],
          "rsg": "u-cjk",
          "tex": {
            "block": "\\cn",
            "codepoint": "{\\tfRaise{-0.1}\\cnxBabel{}é¾µ}"
          }
        }
      ], [
        "â¿¸", {
          "tag": ["assigned", "cjk", "idl"],
          "rsg": "u-cjk-idc",
          "tex": {
            "codepoint": "{\\tfRaise{-0.2}\\cnxJzr{}î€°}"
          }
        }
      ], [
        "é‡’", {
          "tag": ["assigned", "cjk", "ideograph", "sim", "sim/has-target", "sim/is-source", "sim/has-target/components", "sim/is-source/components", "sim/components"],
          "rsg": "u-cjk",
          "sim/target/components": ["é‡‘"],
          "tex": {
            "block": "\\cn",
            "codepoint": "{\\tfPush{0.4}é‡’}"
          }
        }
      ], [
        "é‡‘", {
          "tag": ["assigned", "cjk", "ideograph", "sim/has-source/global", "sim/is-target/global", "sim/global", "sim", "sim/has-source", "sim/is-target", "sim/has-source/components", "sim/is-target/components", "sim/components"],
          "rsg": "u-cjk",
          "sim/source/global": ["ï¤Š", "â¾¦"],
          "sim/source/components": ["é‡’"],
          "tex": {
            "block": "\\cn"
          }
        }
      ], [
        "ð¤´”", {
          "tag": ["assigned", "cjk", "ideograph", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"],
          "rsg": "u-cjk-xb",
          "sim/source/global": ["âºª"],
          "tex": {
            "block": "\\cnxb",
            "codepoint": "{\\cnxBabel{}ð¤´”}"
          }
        }
      ], [
        "ä¸¨", {
          "tag": ["assigned", "cjk", "ideograph", "sim/has-source/global", "sim/is-target/global", "sim/global", "sim", "sim/has-source", "sim/is-target", "sim/has-source/components/search", "sim/is-target/components/search", "sim/components/search"],
          "rsg": "u-cjk",
          "sim/source/global": ["ã€¡", "â¼", "ã‡‘"],
          "sim/source/components/search": ["äº…"],
          "tex": {
            "block": "\\cn"
          }
        }
      ], [
        "äº…", {
          "tag": ["assigned", "cjk", "ideograph", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global", "sim", "sim/has-target", "sim/is-source", "sim/has-target/components/search", "sim/is-source/components/search", "sim/components/search"],
          "rsg": "u-cjk",
          "sim/source/global": ["â¼…", "ã‡š"],
          "sim/target/components/search": ["ä¸¨"],
          "tex": {
            "block": "\\cn"
          }
        }
      ], [
        "ã…", {
          "tag": ["assigned", "cjk", "ideograph", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global", "sim", "sim/has-target", "sim/is-source", "sim/has-target/components", "sim/is-source/components", "sim/components"],
          "rsg": "u-cjk-xa",
          "sim/source/global": ["ã€¤"],
          "sim/target/components": ["ä¹‚"],
          "tex": {
            "block": "\\cnxa"
          }
        }
      ], [
        "ä¹‚", {
          "tag": ["assigned", "cjk", "ideograph", "sim", "sim/has-source", "sim/is-target", "sim/has-source/components", "sim/is-target/components", "sim/components"],
          "rsg": "u-cjk",
          "sim/source/components": ["ã…", "ä¹„"],
          "tex": {
            "block": "\\cn"
          }
        }
      ]
    ];
    for (j = 0, len1 = probes_and_matchers.length; j < len1; j++) {
      ref = probes_and_matchers[j], probe = ref[0], matcher = ref[1];
      description = ISL.aggregate(u, probe, recipe);
      T.eq(description, matcher);
      info(probe);
      urge('  tag:', ((ref1 = description['tag']) != null ? ref1 : ['-/-']).join(', '));
      urge('  rsg:', description['rsg']);
      for (k = 0, len2 = sim_tags.length; k < len2; k++) {
        sim_tag = sim_tags[k];
        if ((value = description[sim_tag]) == null) {
          continue;
        }
        urge("  " + sim_tag + ":", value);
      }
      urge('  blk:', (ref2 = (ref3 = description['tex']) != null ? ref3['block'] : void 0) != null ? ref2 : '-/-');
      urge('  cp: ', (ref4 = (ref5 = description['tex']) != null ? ref5['codepoint'] : void 0) != null ? ref4 : '-/-');
    }
    return null;
  };

  demo_2 = function() {
    var cid, entry, entry_tag, i, j, len, len1, ref, search_tag, source_fncr, source_glyph, source_glyph_info, tag, tags, target_fncr, target_glyph, target_glyph_info;
    tags = ['global', 'components', 'components/search', 'false-identity'];
    for (i = 0, len = tags.length; i < len; i++) {
      tag = tags[i];
      echo(tag);
      search_tag = "sim/is-target/" + tag;
      entry_tag = "sim/source/" + tag;
      ref = MKNCR._ISL.find_entries(u, 'tag', search_tag);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        entry = ref[j];

        /* Silently assuming that all relevant entries represent single-character intervals */
        target_glyph_info = MKNCR.analyze((cid = entry['lo']));
        target_glyph = target_glyph_info['uchr'];
        target_fncr = target_glyph_info['fncr'];
        source_glyph = entry[entry_tag];
        source_glyph_info = MKNCR.analyze(source_glyph);
        source_fncr = source_glyph_info['fncr'];
        echo(target_fncr, target_glyph, '<-', source_fncr, source_glyph);
      }
    }
    return null;
  };

  if (module.parent == null) {
    include = ["aggregate", "SIMs, TeX formats"];
    this._prune();
    this._main();
  }

}).call(this);

//# sourceMappingURL=tests.js.map
