// Generated by CoffeeScript 1.10.0
(function() {
  var CND, ISL, MKNCR, alert, badge, debug, demo_2, echo, help, include, info, log, rpr, step, test, u, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CND = require('cnd');

  rpr = CND.rpr.bind(CND);

  badge = 'MINGKWAI-NCR/tests';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  test = require('guy-test');

  step = require('coffeenode-suspend').step;

  MKNCR = require('./main');

  ISL = MKNCR._ISL;

  u = MKNCR.unicode_isl;

  this._prune = function() {
    var name, value;
    for (name in this) {
      value = this[name];
      if (name.startsWith('_')) {
        continue;
      }
      if (indexOf.call(include, name) < 0) {
        delete this[name];
      }
    }
    return null;
  };

  this._main = function() {
    return test(this, {
      'timeout': 3000
    });
  };

  this["demo"] = function(T) {
    var cid, glyph, i, len, ref;
    ref = MKNCR.chrs_from_text("《🖹");
    for (i = 0, len = ref.length; i < len; i++) {
      glyph = ref[i];
      cid = MKNCR.as_cid(glyph);
      debug(glyph, ISL.aggregate(u, cid));
    }
    return null;
  };

  this["aggregate"] = function(T) {
    var i, len, matcher, probe, probes_and_matchers, reducers, ref, result;
    u = MKNCR.unicode_isl;
    ISL = MKNCR._ISL;
    probes_and_matchers = [
      [
        "q", {
          "tag": ["assigned"],
          "rsg": "u-latn"
        }
      ], [
        "里", {
          "tag": ["assigned", "cjk", "ideograph", "sim", "sim/has-source", "sim/is-target", "sim/has-source/global", "sim/is-target/global", "sim/global"],
          "rsg": "u-cjk"
        }
      ], [
        "䊷", {
          "tag": ["assigned", "cjk", "ideograph"],
          "rsg": "u-cjk-xa"
        }
      ], [
        "《", {
          "tag": ["assigned", "cjk", "punctuation"],
          "rsg": "u-cjk-sym"
        }
      ], [
        "🖹", {
          "tag": ["assigned"]
        }
      ], [
        "🛷", {
          "tag": ["unassigned"]
        }
      ], [
        887, {
          "tag": ["assigned"],
          "rsg": "u-grek"
        }
      ], [
        888, {
          "tag": ["unassigned"],
          "rsg": "u-grek"
        }
      ], [
        889, {
          "tag": ["unassigned"],
          "rsg": "u-grek"
        }
      ], [
        890, {
          "tag": ["assigned"],
          "rsg": "u-grek"
        }
      ]
    ];
    reducers = {
      '*': 'skip',
      'tag': 'tag',
      'rsg': 'assign'
    };
    for (i = 0, len = probes_and_matchers.length; i < len; i++) {
      ref = probes_and_matchers[i], probe = ref[0], matcher = ref[1];
      result = ISL.aggregate(u, probe, reducers);
      debug('32771', JSON.stringify([probe, result]));
      T.eq(result, matcher);
    }
    return null;
  };

  this["SIMs, TeX formats"] = function(T) {
    var description, glyph, i, j, k, len, len1, len2, reducers, ref, ref1, ref2, ref3, ref4, ref5, sim_tag, sim_tags, text, value;
    sim_tags = ['sim/source/global', 'sim/source/components', 'sim/source/components/search', 'sim/source/false-identity', 'sim/target/global', 'sim/target/components', 'sim/target/components/search', 'sim/target/false-identity'];
    reducers = {
      '*': 'skip',
      tag: 'tag',
      rsg: 'assign',
      tex: function(values, context) {

        /* TAINT should be a standard reducer */
        var R, i, len, name, sub_value, value;
        R = {};
        for (i = 0, len = values.length; i < len; i++) {
          value = values[i];
          for (name in value) {
            sub_value = value[name];
            R[name] = sub_value;
          }
        }
        return R;
      }
    };
    for (i = 0, len = sim_tags.length; i < len; i++) {
      sim_tag = sim_tags[i];
      reducers[sim_tag] = 'list';
    }
    text = '龵⿸釒金𤴔丨亅㐅乂';
    text = '釒';
    ref = Array.from(text);
    for (j = 0, len1 = ref.length; j < len1; j++) {
      glyph = ref[j];
      description = ISL.aggregate(u, glyph, reducers);
      info(glyph);
      urge('  tag:', ((ref1 = description['tag']) != null ? ref1 : ['-/-']).join(', '));
      urge('  rsg:', description['rsg']);
      for (k = 0, len2 = sim_tags.length; k < len2; k++) {
        sim_tag = sim_tags[k];
        if ((value = description[sim_tag]) == null) {
          continue;
        }
        urge("  " + sim_tag + ":", value);
      }
      urge('  blk:', (ref2 = (ref3 = description['tex']) != null ? ref3['block'] : void 0) != null ? ref2 : '-/-');
      urge('  cp: ', (ref4 = (ref5 = description['tex']) != null ? ref5['codepoint'] : void 0) != null ? ref4 : '-/-');
    }
    return null;
  };

  demo_2 = function() {
    var cid, entry, entry_tag, i, j, len, len1, ref, search_tag, source_fncr, source_glyph, source_glyph_info, tag, tags, target_fncr, target_glyph, target_glyph_info;
    tags = ['global', 'components', 'components/search', 'false-identity'];
    for (i = 0, len = tags.length; i < len; i++) {
      tag = tags[i];
      echo(tag);
      search_tag = "sim/is-target/" + tag;
      entry_tag = "sim/source/" + tag;
      ref = MKNCR._ISL.find_entries(u, 'tag', search_tag);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        entry = ref[j];

        /* Silently assuming that all relevant entries represent single-character intervals */
        target_glyph_info = MKNCR.analyze((cid = entry['lo']));
        target_glyph = target_glyph_info['uchr'];
        target_fncr = target_glyph_info['fncr'];
        source_glyph = entry[entry_tag];
        source_glyph_info = MKNCR.analyze(source_glyph);
        source_fncr = source_glyph_info['fncr'];
        echo(target_fncr, target_glyph, '<-', source_fncr, source_glyph);
      }
    }
    return null;
  };

  if (module.parent == null) {
    include = ["aggregate", "SIMs, TeX formats"];
    this._prune();
    this._main();
  }

}).call(this);

//# sourceMappingURL=tests.js.map
